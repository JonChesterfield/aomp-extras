///
///  hostcall_stubs.cu
///

/// #include <stdio.h>
#include "hip/hip_runtime.h"
#include "hostcall_service_id.h"
#include "hostcall_stubs.h"

struct omptarget_device_environmentTy {
  int32_t debug_level;   // gets value of envvar LIBOMPTARGET_DEVICE_RTL_DEBUG
                         // only useful for Debug build of deviceRTLs
  int32_t num_devices;   // gets number of active offload devices
  int32_t device_num;    // gets a value 0 to num_devices-1
  int32_t services_buffer_size; // a buffer to proxy host services for GPU
  int32_t services_buffer_end;  // atomically set when buffer updated
  void *services_buffer;
};
extern __device__ omptarget_device_environmentTy omptarget_device_environment;

// -----------------------------------------------------------------------------
//
// printf: stubs to support printf 
//
// GPUs typically do not support vaargs style functions.  So to implement
// printf or any vaargs function as a hostcall service requires the compiler 
// to generate code to allocate a buffer, fill the buffer with the value of
// each argument, and then call a stub to execute the service with a pointer to 
// the buffer. The clang compiler does this in the CGGPUBuiltin.cpp source.
// Here we define printf_alloc and printf_execute device functions that are
// generated by the clang compiler when it encounters a printf statement.
// printf_alloc is implemented as a hostcall stub. We assume that the 
// host routine for printf_execute will free the buffer that was allocated
// by printf_alloc.

EXTERN char * hostcall_quick_alloc(uint bufsz); 
EXTERN char * printf_alloc(uint bufsz) {
/*	
  if (__device__ char* quick_buffer = hostcall_quick_alloc(bufsz)) {
     return quick_buffer;
  }
 */
  ulong arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (ulong) bufsz;

  hostcall_result_t result = hostcall_invoke(HOSTCALL_SERVICE_MALLOC,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  int rc = (int) result.arg0;

  arg0 = result.arg1;  // Temp LOOPTEST TO ANOTHER MALLOC SERVICE THAT DOES NOTHING
  result = hostcall_invoke(HOSTCALL_SERVICE_MALLOC,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);

  char* print_buffer = (char*) result.arg1;
  return print_buffer;
}

EXTERN int printf_execute(char * print_buffer, uint bufsz) { 
  ulong arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (ulong) print_buffer ;
  arg1 = (ulong) bufsz;

  hostcall_result_t result = hostcall_invoke(HOSTCALL_SERVICE_PRINTF,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  return (int) result.arg0;
}

// This utility is used for printf arguments that are variable length strings
// The clang compiler will generate calls to this only when a string length is 
// not a compile time constant.
EXTERN uint32_t __strlen_max(char *instr, uint32_t maxstrlen) {
  for (uint32_t i = 0; i < maxstrlen ; i++)
    if (instr[i] == (char) 0 )
       return (uint32_t) (i+1);
  return maxstrlen;
}


EXTERN char *hostcall_quick_alloc(uint bufsz) {
#define SBHEADERSZ 8
  // Update the 8 byte header in the actual services buffer.
  char *ptr = (char *)omptarget_device_environment.services_buffer;
  uint oldval  = ((uint *)ptr)[0];
  uint maxsize = ((uint *)ptr)[1];
  uint newval = atomicAdd((unsigned int *)ptr,bufsz);
  for (;;) {
    if (SBHEADERSZ + newval > maxsize)
      return NULL;
    if (atomicCAS((unsigned int *)ptr, oldval , newval))
      break;
  }
  // Now update the used end size of the device_environment structure itself
  // Having two avoids a device memcpy if there are no services.
  // In the future we may want to get rid of the 8 byte service header
  // and just update the device_environment structure.
  uint end_oldval = omptarget_device_environment.services_buffer_end;
  uint end_newval = atomicAdd(&(omptarget_device_environment.services_buffer_end),bufsz);
  for (;;) {
    if (atomicCAS(&(omptarget_device_environment.services_buffer_end), end_oldval ,end_newval))
      break;
  }
  //  FIXME: This seems wrong 
  return ptr + SBHEADERSZ + newval;
}


// -----------------------------------------------------------------------------
//
// vector_product_zeros: Example stub to demonstrate hostcall services
//
// This is an example hostcall stub for a service called vector_product_zeros.
// This function calculates C = A*B and returns the number of zeros.
// Naturally, one would typically do this type of operation on a GPU. 
// But this is a demo  to illustrate the use of hostcall to run a service
// on the host. This is the definition of vector_product_zeros that the 
// host will execute:
//
// int vector_product_zeros(int N, int*A, int*B, int*C) {
//    int zeros = 0;   
//    for (int i =0 ; i<N; i++) {
//       C[i] = A[i] * B[i];
//       if ( C[i] == 0  )
//          zeros++ ;
//    }
//    return zeros;
// }
//
EXTERN int vector_product_zeros(int N, int*A,  int*B, int*C) {
  ulong arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;

  arg0 = (long) N;
  // Pass these pointers to the host for memcpy
  arg1 = (long) A;
  arg2 = (long) B;
  arg3 = (long) C;

  hostcall_result_t result = hostcall_invoke(HOSTCALL_SERVICE_DEMO,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  int rc = (int) result.arg0;
  int num_zeros = (int) result.arg1;

  // TODO: Verify rc == 0 and Verify result.arg2 == (long) C)

  return num_zeros;
}
