///
///  hostcall_stubs.cu
///

#include "hip/hip_runtime.h"
#
#ifdef USE_NEW_PRINTF
#include "hostcall_service_id.h"
#include "hostcall_stubs.h"

struct omptarget_device_environmentTy {
  int32_t debug_level;   // gets value of envvar LIBOMPTARGET_DEVICE_RTL_DEBUG
                         // only useful for Debug build of deviceRTLs
  int32_t num_devices;   // gets number of active offload devices
  int32_t device_num;    // gets a value 0 to num_devices-1
  int32_t services_buffer_size; // a buffer to proxy host services for GPU
  int32_t services_buffer_end;  // atomically set when buffer updated
  void *services_buffer;
};
extern __device__ omptarget_device_environmentTy omptarget_device_environment;

// -----------------------------------------------------------------------------
//
// printf: stubs to support printf 
//
// GPUs typically do not support vaargs style functions.  So to implement
// printf or any vaargs function as a hostcall service requires the compiler 
// to generate code to allocate a buffer, fill the buffer with the value of
// each argument, and then call a stub to execute the service with a pointer to 
// the buffer. The clang compiler does this in the CGGPUBuiltin.cpp source.
// Here we define printf_alloc and printf_execute device functions that are
// generated by the clang compiler when it encounters a printf statement.
// printf_alloc is implemented as a hostcall stub. We assume that the 
// host routine for printf_execute will free the buffer that was allocated
// by printf_alloc.

EXTERN char * printf_alloc(uint bufsz) {
  ulong arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (ulong) bufsz;

  hostcall_result_t result = hostcall_invoke(HOSTCALL_SERVICE_MALLOC,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  int rc = (int) result.arg0;

  arg0 = result.arg1;  // Temp LOOPTEST TO ANOTHER MALLOC SERVICE THAT DOES NOTHING
  result = hostcall_invoke(HOSTCALL_SERVICE_MALLOC,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);

  char* print_buffer = (char*) result.arg1;
  return print_buffer;
}

EXTERN int printf_execute(char * print_buffer, uint bufsz) { 
  ulong arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;
  arg0 = (ulong) print_buffer ;
  arg1 = (ulong) bufsz;

  hostcall_result_t result = hostcall_invoke(HOSTCALL_SERVICE_PRINTF,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  return (int) result.arg0;
}

// This utility is used for printf arguments that are variable length strings
// The clang compiler will generate calls to this only when a string length is 
// not a compile time constant.
EXTERN uint32_t __strlen_max(char *instr, uint32_t maxstrlen) {
  for (uint32_t i = 0; i < maxstrlen ; i++)
    if (instr[i] == (char) 0 )
       return (uint32_t) (i+1);
  return maxstrlen;
}

// -----------------------------------------------------------------------------
//
// vector_product_zeros: Example stub to demonstrate hostcall services
//
// This is an example hostcall stub for a service called vector_product_zeros.
// This function calculates C = A*B and returns the number of zeros.
// Naturally, one would typically do this type of operation on a GPU. 
// But this is a demo  to illustrate the use of hostcall to run a service
// on the host. This is the definition of vector_product_zeros that the 
// host will execute:
//
// int vector_product_zeros(int N, int*A, int*B, int*C) {
//    int zeros = 0;   
//    for (int i =0 ; i<N; i++) {
//       C[i] = A[i] * B[i];
//       if ( C[i] == 0  )
//          zeros++ ;
//    }
//    return zeros;
// }
//
EXTERN int vector_product_zeros(int N, int*A,  int*B, int*C) {
  ulong arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7;

  arg0 = (long) N;
  // Pass these pointers to the host for memcpy
  arg1 = (long) A;
  arg2 = (long) B;
  arg3 = (long) C;

  hostcall_result_t result = hostcall_invoke(HOSTCALL_SERVICE_DEMO,
    arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7);
  int rc = (int) result.arg0;
  int num_zeros = (int) result.arg1;

  // TODO: Verify rc == 0 and Verify result.arg2 == (long) C)

  return num_zeros;
}

#else

//================================================================================
//      OLD printf routines 
//==============================================================================-=

#include "../../../../openmp/libomptarget/plugins/hsa/src/hipsrv.h"
#define EXTERN extern "C" __device__
#include "../../../../openmp/libomptarget/src/device_env_struct.h"
extern __device__ omptarget_device_environmentTy omptarget_device_environment;

EXTERN int printf_execute(char * print_buffer, uint bufsz) { 
  return 0;
}

EXTERN uint32_t __strlen_max(char *instr, uint32_t maxstrlen) {
  for (uint32_t i = 0; i < maxstrlen ; i++)
    if (instr[i] == (char) 0 )
       return (uint32_t) (i+1);
  return maxstrlen;
}

#define SBHEADERSZ 8
EXTERN char *alloc_service_buffer(uint bufsz) {
  // Update the 8 byte header in the actual services buffer.
  char *ptr = (char *)omptarget_device_environment.services_buffer;
  uint oldval  = ((uint *)ptr)[0];
  uint maxsize = ((uint *)ptr)[1];
  uint newval = atomicAdd((unsigned int *)ptr,bufsz);
  for (;;) {
    if (SBHEADERSZ + newval > maxsize)
      return NULL;
    if (atomicCAS((unsigned int *)ptr, oldval , newval))
      break;
  }
  // Now update the used end size of the device_environment structure itself
  // Having two avoids a device memcpy if there are no services.
  // In the future we may want to get rid of the 8 byte service header
  // and just update the device_environment structure.
  uint end_oldval = omptarget_device_environment.services_buffer_end;
  uint end_newval = atomicAdd(&(omptarget_device_environment.services_buffer_end),bufsz);
  for (;;) {
    if (atomicCAS(&(omptarget_device_environment.services_buffer_end), end_oldval ,end_newval))
      break;
  }
  return ptr + SBHEADERSZ + newval;
}

EXTERN char *printf_alloc(uint data_and_strlen) {
  size_t headsize = sizeof(hipsrv_service_header_t);
  uint buffsize = (uint)headsize + data_and_strlen;
  __device__ char *buffer = alloc_service_buffer(buffsize);
  if (buffer) {
    __device__ hipsrv_service_header_t *header =
        (hipsrv_service_header_t *)buffer;
    header->size = buffsize;
    header->service_id = (hipsrv_service_id_t) HIPSRV_SERVICE_PRINTF;
    header->device_hipsrv_id = (hipsrv_id_t) HIPSRV_ID;
    return (buffer + headsize);
  } else
    return NULL;
}
#endif
